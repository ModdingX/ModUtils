import net.minecraftforge.gradle.common.util.ModConfig
import net.minecraftforge.gradle.common.util.RunConfig
import org.apache.maven.artifact.versioning.ComparableVersion
import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.apache.maven.artifact.versioning.VersionRange
import org.codehaus.plexus.util.FileUtils

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption


buildscript {
    if (Files.isRegularFile(file('buildscript.gradle').toPath())) {
        println('Loading local buildscript.')
        apply from: "buildscript.gradle", to: buildscript
    } else {
        apply from: "https://raw.githubusercontent.com/noeppi-noeppi/ModUtils/master/buildscript.gradle", to: buildscript
    }
}

final VersionRange gradleVersion = VersionRange.createFromVersionSpec('[6.7,)')

if (!gradleVersion.containsVersion(new DefaultArtifactVersion(gradle.gradleVersion))) {
    throw new IllegalStateException("Gradle version ${gradle.gradleVersion} does not match required version range: ${gradleVersion}")
}

if (!Files.isRegularFile(file('gradle.properties').toPath())) {
    Files.copy(new URL("https://raw.githubusercontent.com/noeppi-noeppi/ModUtils/master/gradle.properties").openStream(), file('gradle.properties').toPath())
    throw new RuntimeException("Default gradle.properties file created. Re-run your build now.")
}

[
        'modid', 'group', 'base_version', 'mc_version', 'forge_version', 'local_maven', 'mixins', 'license_name',
        'license_url'
].stream().filter { !project.hasProperty(it) }.findFirst()
        .ifPresent { throw new IllegalStateException("${it} should be defined in gradle.properties.") }

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'com.matthewprenger.cursegradle'
apply plugin: 'maven-publish'
apply plugin: 'org.spongepowered.mixin'

apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/generic/secrets.gradle'
apply from: 'https://raw.githubusercontent.com/MinecraftModDevelopment/Gradle-Collection/master/generic/markdown-git-changelog.gradle'

loadSecrets()

archivesBaseName = "${modid}-${mc_version}"
version = getVersion()

java.toolchain.languageVersion = JavaLanguageVersion.of(8)

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))
println('Mod: ' + archivesBaseName + ' Group: ' + group + ' Version: ' + version)

minecraft {
    if (project.hasProperty('mappings')) {
        String mappingsStr = ((String) project.getProperty('mappings'))
        mappings channel: mappingsStr.substring(0, mappingsStr.indexOf(':')), version: mappingsStr.substring(mappingsStr.indexOf(':') + 1)
    } else {
        mappings channel: 'official', version: mc_version
    }
    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')
    createRunConfig("client")
    createRunConfig("server")
    createRunConfig("data", { RunConfig run ->
        run.args "--mod", modid, "--all", "--output", file("src/generated/resources/"), "--existing", file("src/main/resources")
    })
}

if (Boolean.parseBoolean(project.mixins)) {
    mixin {
        add sourceSets.main, "libx.refmap.json"
    }
}

def createRunConfig(String name, Closure extra = {}) {
    minecraft.runs.create(name) { RunConfig run ->
        run.workingDirectory project.file("run" + name.capitalize())
        run.property "forge.logging.markers", "SCAN,REGISTRIES"
        run.jvmArg "-Dmixin.env.disableRefMap=true"
        run.property "forge.logging.console.level", "debug"
        if (Boolean.parseBoolean(project.mixins)) {
            // Weirdly a GString does not work here
            run.arg "-mixin.config=" + project.modid + ".mixins.json"
        }
        run.mods.create(modid) { ModConfig mod ->
            source sourceSets.main
        }
    }.with(extra)
}

sourceSets.main.resources {
    srcDir 'src/generated/resources'
}

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"

    if (Boolean.parseBoolean(project.mixins)) {
        annotationProcessor 'org.spongepowered:mixin:0.8.2:processor'
    }
}

jar {
    manifest {
        attributes([
                'Specification-Title'     : project.modid,
                'Specification-Version'   : '1',
                'Implementation-Title'    : project.name,
                'Implementation-Version'  : project.version,
                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
        if (Boolean.parseBoolean(project.mixins)) {
            attributes.put('MixinConfigs', "${project.modid}.mixins.json")
        }
    }
}

jar.finalizedBy('reobfJar')

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId = project.group
            artifactId = project.archivesBaseName
            version = project.version
            artifact jar
            pom {
                licenses {
                    license {
                        name = project.license_name
                        url = project.license_url
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url project.local_maven
        }
    }
}

curseforge {
    apiKey = findProperty('curse_auth') ?: 0
    if (project.hasProperty('curse_project')) {
        project {
            id = "${curse_project}"
            releaseType = project.findProperty('curse_release') ?: 'alpha'
            changelog = getGitChangelog()
            println(changelog)
            changelogType = 'markdown'

            ((project.findProperty('curse_versions') ?: project.mc_version) as String).split(',').each {
                addGameVersion "${it}"
            }

            if (project.hasProperty('curse_requirements') || project.hasProperty('curse_optionals')) {
                mainArtifact(jar) {
                    relations {
                        if (project.hasProperty('curse_requirements')) {
                            project.getProperty('curse_requirements').split(',').each {
                                requiredDependency "${it}"
                            }
                        }

                        if (project.hasProperty('curse_optionals')) {
                            project.getProperty('curse_optionals').split(',').each {
                                optionalDependency "${it}"
                            }
                        }
                    }
                }
            }
        }
    }
}

private String getVersion() {
    java.nio.file.Path mavenPath = file(local_maven).toPath().resolve(group.replace('.', '/')).resolve(archivesBaseName)
    if (!Files.isDirectory(mavenPath)) {
        return "${base_version}.0"
    }
    return "${baseVersion}." + Files.walk(mavenPath)
            .filter { path -> Files.isRegularFile(path) && path.getFileName().toString().endsWith('.pom') }
            .map { path ->
                String fileName = path.getFileName().toString()
                fileName.substring(fileName.indexOf('-', archivesBaseName.size()) + 1, fileName.length() - 4)
            }.filter { version -> version.startsWith(base_version) }
            .max { s1, s2 -> (new ComparableVersion(s1) <=> new ComparableVersion(s2)) }
            .map { ver -> ver.substring(ver.findLastIndexOf { str -> !"0123456789".contains(str) } + 1) }
            .map { ver -> ver.isEmpty() ? "-1" : ver }
            .map { ver -> (ver.toInteger() + 1).toString() }
            .orElse("0")
}

task setup {
    outputs.upToDateWhen { false }
    doFirst {
        java.nio.file.Path clone = Files.createTempDirectory('mod-gradle')
        ProcessBuilder process = new ProcessBuilder()
                .inheritIO()
                .command('git', 'clone', 'https://github.com/noeppi-noeppi/ModUtils.git', clone.toAbsolutePath().normalize().toString())
        int exitCode = process.start().waitFor()
        if (exitCode != 0) {
            throw new IllegalStateException("Failed to clone repository from github.")
        }
        if (!Files.exists(file('runClient').toPath()) || Files.list(file('runClient').toPath()).count() == 0) {
            FileUtils.copyDirectory(clone.resolve('runClient').toFile(), file('runClient'))
        }
        if (!Files.exists(file('runServer').toPath()) || Files.list(file('runServer').toPath()).count() == 0) {
            FileUtils.copyDirectory(clone.resolve('runServer').toFile(), file('runServer'))
        }
        if (!Files.exists(file('runData').toPath()) || Files.list(file('runData').toPath()).count() == 0) {
            FileUtils.copyDirectory(clone.resolve('runData').toFile(), file('runData'))
        }
        Files.copy(clone.resolve('mod.gitignore'), file('.gitignore').toPath(), StandardCopyOption.REPLACE_EXISTING)
        if (!Files.exists(clone.resolve('Jenkinsfile'))) {
            Files.copy(clone.resolve('Jenkinsfile'), file('Jenkinsfile').toPath())
        }
        Files.createDirectories(file("src/main/java/${project.group.replace('.', '/')}/${project.modid}").toPath())
        Files.createDirectories(file("src/main/resources/META-INF").toPath())
        Files.createDirectories(file("src/main/resources/assets/${project.modid}/lang").toPath())
        Files.createDirectories(file("src/main/resources/data/${project.modid}").toPath())
        Files.createDirectories(file("src/generated/resources").toPath())
        if (!Files.exists(file('src/main/resources/META-INF/accesstransformer.cfg').toPath())) {
            Files.createFile(file('src/main/resources/META-INF/accesstransformer.cfg').toPath())
        }
        String loaderVersion
        String requiredForgeVersion
        if (project.forge_version.contains('.')) {
            loaderVersion = project.forge_version.substring(0, project.forge_version.indexOf('.'))
            requiredForgeVersion = project.forge_version.substring(0, project.forge_version.lastIndexOf('.'))
        } else {
            loaderVersion = project.forge_version
            requiredForgeVersion = project.forge_version
        }
        if (!Files.exists(file('src/main/resources/META-INF/mods.toml').toPath())) {
            Files.write(file('src/main/resources/META-INF/mods.toml').toPath(), [
                    "modId=\"${project.modid}\"",
                    "loaderVersion=\"[${loaderVersion},)\"",
                    "license=\"${project.license_name}\"",
                    'issueTrackerURL=""',
                    '',
                    '[[mods]]',
                    "modId=\"${project.modid}\"",
                    'version="${file.jarVersion}"',
                    "displayName=\"${(project.modid as String).capitalize()}\"",
                    'displayURL=""',
                    'authors=""',
                    'description="""',
                    '"""',
                    '',
                    "[[dependencies.${project.modid}]]",
                    '    modId="forge"',
                    '    mandatory=true',
                    "    versionRange=\"[${requiredForgeVersion},)\"",
                    '    ordering="NONE"',
                    '    side="BOTH"',
                    '',
                    "[[dependencies.${project.modid}]]",
                    '    modId="minecraft"',
                    '    mandatory=true',
                    "    versionRange=\"[${project.mc_version},)\"",
                    '    ordering="NONE"',
                    '    side="BOTH"'
            ], StandardOpenOption.CREATE)
        }
        if (Boolean.parseBoolean(project.mixins) && !Files.exists(file("src/main/resources/${project.modid}.mixins.json").toPath())) {
            Files.write(file("src/main/resources/${project.modid}.mixins.json").toPath(), [
                    '{',
                    '  "required": true,',
                    '  "compatibilityLevel": "JAVA_8",',
                    "  \"refmap\": \"${project.modid}.refmap.json\",",
                    "  \"package\": \"${project.group}.${project.modid}.mixin\",",
                    '  "minVersion": "0.8",',
                    '  "client": [],',
                    '  "server": [],',
                    '  "mixins": []',
                    '}'
            ], StandardOpenOption.CREATE)
        }
        if (!Files.exists(file('LICENSE').toPath())) {
            Files.copy(new URL(project.license_url).openStream(), file('LICENSE').toPath())
        }
    }
}

// Prevent Mixin annotation processor from getting into IDEA's annotation processor settings
if (Boolean.parseBoolean(project.mixins) && System.getProperty("idea.sync.active") == "true") {
    afterEvaluate {
        tasks.withType(JavaCompile).all {
            it.options.annotationProcessorPath = files()
        }
    }
}

ext {
    setup = this.setup
}